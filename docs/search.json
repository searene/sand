[{"categories":null,"content":"Nowadays TODO management apps are everywhere. From giant tech companies to emerging individual developers, everyone is creating TODO apps. Even some programming tutorials are about how to create a TODO app. The reason behind its popularity is obvious: almost everyone needs a TODO app. But unfortunately, only a small number of people know how to manage TODO tasks most efficiently.\nDo you know how to use a TODO app? Yes, of course you do. Just open a TODO app and add some TODO tasks to it. When one of them is finished, simply mark them as finished by clicking on the little square before each TODO item, it’s that simple, right? Yes, it could be that simple, you can manage your TODO tasks successfully in this way. But in my view, you missed an important part: you didn’t leave any notes for your TODO tasks.\nYou may have indulged deeply in your usual task-management process, to the extent that you may not even realize the note-taking part is important. So let me give you some examples. Suppose you created the following TODO task that you needed to finish today:\nSome users report that my app sometimes runs slow, I need to pinpoint the reason and fix it. After several hours of debugging and coding, you finally found the reason and fixed the problem. With fulfillment, you opened your TODO app again and marked it as finished. “Good job!” You said to yourself: “Nothing is wrong here”.\nBut really? In my view, you missed an important part: taking notes for the TODO tasks. You should write down how you find the reason for slowness, how you fixed it, and how to avoid similar problems in the future. What’s more, the notes are not taken after you solved the problem, they are taken along the process of solving it. Only in that way can you benefit from the notes most.\nAdvantages of Taking Notes for TODO Tasks Why should I take notes for my TODO tasks? Isn’t it enough to just finish the task in any way I want? After all, the most important thing is that I’ve completed the task, right? Well, maybe, but if you don’t take notes for those tasks, you may miss something. There are some clear benefits to taking notes for TODO tasks, to name a few:\nYou may encounter similar problems in the future. When that happens, you can refer to the current notes as a problem-solving template.\nYou may find some of those notes useful in the future, even if you won’t encounter similar problems again. For example, when solving the problem, you may learn some knowledge about CPU. You can just note them down. When you want to look up something you’ve learned about CPU several months later, you can search for “CPU” in the notes, and voila! That knowledge, along with the context - the slowness bug - pops up in front of you. Context-aware resources can help you learn more quickly and deeply.\nThe notes can guide you through solving the problem. This is the MOST IMPORTANT reason why you should take notes for your TODO task. As an old saying goes:\nWriting is not the artifact of thinking, it’s the actual thinking process.\nI believe you won’t solve the slowness problem immediately, at least not every time. You have to first reproduce the problem, then monitor all the relevant indicators to see if anything is abnormal. You may also need to adjust some parameters to see what happens. You can write all of them in the notes, and let the notes guide you through solving the problem. It’s just like solving a mathematical problem. Some problems are hard to solve. Whenever an idea comes to your mind, you need to write them down in a notebook, fiddle around with them for a while, and maybe after writing enough information can you find the right way to solve it.\nThat being said, do notice that some TODO tasks are not suitable for taking notes. Like “Remember to take out the garbage first thing in the morning” or “Finish the code for the sharing functionality of my app”. The former is too simple to note anything down, the latter is more about coding, which is usually done in an IDE, not much to be written down in the notes.\nLet’s take an example Now suppose you want to fix the problem mentioned above:\nSome users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.\nTo do that, you first created a TODO task:\nTODO Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.\nAfter creating the task, we are ready to get down to it. As everyone knows, the first thing we need to do when solving a problem would be to try reproducing it. So let’s add the following notes under the TODO task before doing anything.\nTODO Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.\nNOTES First let's try reproducing the issue by following the user's guide:\nStart the app. Click on the \"START\" button to start processing. Observe the duration to be longer than expected. After writing those notes, you started the app, clicked on the button, and found the duration to be 30 seconds, longer than the expected 3 seconds. You also wrote that in the notes\nTODO Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.\nNOTES First let's try reproducing the issue by following the user's guide:\nStart the app. Click on the \"START\" button to start processing. Observe the duration to be longer than expected. I've reproduced the issue, the duration is 30 seconds, longer than the expected 3 seconds.\nSo what’s the culprit? You remembered that the number of the app’s users has increased a lot in the past few days, but the number of backend servers for the app hasn’t changed for months. Maybe these servers cannot support that many users’ requests? That’s possible. To verify the assumption, we need to check the servers’ logs to see if the servers’ process duration has increased. As usual, add the action and the corresponding log to the notes:\nTODO Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.\nNOTES First let's try reproducing the issue by following the user's guide:\nStart the app. Click on the \"START\" button to start processing. Observe the duration to be longer than expected. I've reproduced the issue, the duration is 30 seconds, longer than the expected 3 seconds.\nMaybe it's because the backend servers are overloaded. Need to check the servers' logs first.\nThe followings logs are taken from the server with IP 192.168.10.50:\n[2023-07-28 12:00:56] Finished processing user Joey's request, duration: 28 seconds. [2023-07-28 12:02:39] Finished processing user Rachel's request, duration: 32 seconds. So the servers’ request time has indeed increased. The next step would be to check the servers’ various indicators, like CPU, memory, load, etc. You should also append this information to the notes. You get the idea, I won’t go into details anymore. The writing process can guide you through fixing the issue. What’s more, you may find the notes useful someday in the future, I cannot tell you how many times I got valuable information about the past in previous TODO notes!\nAs for Note-Taking, What Counts as a Good TODO App/Scheme? Now you know why TODO notes are important and how to take them, the next question would be which TODO app we should use. But before making a choice, we may need to consider what features we want from a TODO app in terms of note-taking. In my view, three features are the most important:\nIt has to support adding notes for each TODO task. Since we are talking about notes, this feature is an obvious one. The notes should support text formatting like italics, code blocks, etc. This is because our notes could be complicated sometimes. We may need to write code blocks, headers, quotes, etc in the notes to make it easy to understand. It would be hard to take long notes without the feature. The whole TODO list should be stored in, or at least can be imported and exported to, a plain text format. By plain text format, I mean Markdown, Org Mode, etc. They are powerful enough to store multiple formats in a single text file. To be honest, this is not a must-have feature, but it’s nice to have. When your TODO list is stored in a plain text format, you can search for/edit anything you want with any editor, you will not be bound to a certain vendor product. How Does Each TODO App Do in Terms of Note-Taking? Now we have three requirements for TODO apps, let’s take a look at some well-known TODO apps and see how each of them does in this regard.\nMicrosoft To Do One of the most famous TODO apps is Microsoft To Do.\nMicrosoft To Do allows you to take notes for each task at the right bottom part of the UI (Found the “Add Note” part in the image above?). That’s enough for most people, but the notes can only be plain text, it doesn’t support quotes, code blocks, etc. So it’s not the perfect solution. Maybe Microsoft doesn’t want the app to be complicated. If the user needs to take notes with formatting elements (heading, bulleted lists), he/she can do this in other apps. Besides, you can only see/edit TODO tasks inside the app, there is no way to export the TODO list to a text file. So Microsoft To Do only supports the first feature.\nScore: ★★★☆☆\nTodoist Todoist is also a famous TODO management app, it seems to have more features than Microsoft To Do. You can try creating a TODO task and adding some notes to it, then you will immediately realize that the app surely supports the first two features - It supports Markdown in its TODO description/comments and renders it perfectly:\nIt doesn’t support importing/exporting the TODO list to a text file, but it supports the first two features perfectly.\nScore: ★★★★☆\nAgenda Agenda is built based on the idea that notes and dates should be combined together, which is closely aligned with ours. Strictly speaking, it’s not a TODO app, at least not a traditional one, the official website describes the app as Notes meets Calendar. But since it can set a date for a block of notes, you can use it as a TODO app with notes emphasized.\nAgenda has a premium feature that supports exporting the notes into markdown files. I haven’t bought Agenda so I don’t know how it does. But I guess it should work. So in summary, Agenda supports all the three features we mentioned above, which seems to be a great app worth trying.\nScore: ★★★★☆\nEmacs With Org Mode This is my favorite one. But a lot of people don’t know Emacs or Org Mode at all, maybe because it’s a niche product mainly used by programmers.\nFirst of all, Emacs and Org Mode are two separate things. Emacs is a highly-customizable text editor, just like Vim, while Org Mode is a markup language, just like Markdown. It’s not as popular as Markdown so a lot of people don’t know it. Theoretically, you can edit Org Mode documents with any editor, but most people choose Emacs because it has excellent support for Org Mode.\nOrg Mode has many attractive features that are not available in Markdown. Since we are talking about notes and TODO tasks, I’ll only highlight relevant features in Org Mode. In Markdown, we add a header with #. That’s similar in Org Mode, only that we use * instead of #. Moreover, You can add the TODO keyword after * in Org Mode to make it a TODO header, here is an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 * TODO Install Emacs in macOS ** DONE Install vanilla Emacs We can use ~brew~ to install vanilla Emacs, the command is as follows[fn:1]: #+begin_src sh brew update brew install emacs #+end_src ** TODO Install Doom Emacs Run the following command to install Doom Emacs[fn:2]: #+begin_src sh git clone --depth 1 https://github.com/doomemacs/doomemacs ~/.config/emacs ~/.config/emacs/bin/doom install #+end_src * Footnotes [fn:1] [[https://orgmode.org/org.html#Installation][The official Org Mode website]] [fn:2] [[https://github.com/doomemacs/doomemacs][The Doom Emacs git repository]] Here is how it looks like in Emacs (You may get a different rendering effect depending on your Emacs configurations):\nIt’s just like Markdown, only using a different set of symbols. I won’t try to tell you all the meanings of those symbols, but you can guess. Here we created a top TODO task, which is to install Emacs on macOS. When we add this TODO task, we may know nothing about how to do that. After some investigations, we may find that we need to install two parts, the first is vanilla Emacs, and the second is Doom Emacs. Again, you don’t need to know what they are, the point is that we figured out we need to install two parts, so we need to create two sub-tasks under the main task. Then we list all the commands we need to run to install them. We can also attach the result to the notes (By the way, Emacs can run those commands directly in the notes!) so that whenever any error occurs, the result can be taken as a good reference for pinpointing the reason.\nIn the end, when we finished the first sub-task, we change the TODO keyword to DONE, just like we change - [ ] to - [X] in Markdown. It not only removes the TODO task from the TODO list but also gives us “a dose of dopamine” for finishing the task.\nAlthough Org Mode is great in many ways, few apps support Org Mode, and Emacs is almost the only app that supports all the features of Org Mode. Yes, you can edit Org Mode files in any editor you want. But if you want to do something with TODO tasks in Org Mode files, like checking TODO tasks scheduled at a certain date, or checking all the TODO tasks with the highest priority, Emacs might be your only option. And here comes its biggest problem: Emacs is not that easy to learn, even for professional programmers. That is a huge obstacle for ordinary people.\nEmacs with Org Mode supports all the three features mentioned above, but it’s hard to learn, which is a deal killer for most people, so I’ll only give it three stars, although it’s my favorite.\nScore: ★★★☆☆\nNow What Should I Choose? There are many TODO apps nowadays, and most of them support adding notes, only the degree of support varies. You may ask which one to choose, and my answer to that question would be: just pick one, don’t hesitate. In my view, the biggest problem is not that most TODO apps don’t have great support for notes. The biggest problem is that most people don’t know they should take notes for their TODO tasks. So just pick one TODO app, and start taking your TODO notes from today!\n","description":"","tags":null,"title":"Take Notes for Your Todo Tasks","uri":"/posts/take-notes-for-your-todo-tasks/"},{"categories":null,"content":"Introduction Recently I encountered a leetcode problem called Majority Element, there are multiple ways to solve it, the most efficient of them all is called the Boyer-Moore Majority Voting Algorithm, whose time complexity is $O(n)$ and space complexity is $O(1)$. There are many posts online talking about the algorithm, but most of them don’t give a concrete mathematical proof of it. So in this post, I try to explain the algorithm thoroughly, including not only its mechanism and intuition but also a mathematical proof.\nProblem Given an array nums of size $n$, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\n1 2 Input: nums = [3,2,3] Output: 3 Example 2:\n1 2 Input: nums = [2,2,1,1,1,2,2] Output: 2 The Boyer-Moore Majority Voting Algorithm There are a lot of ways to solve the problem, but the method I’ll introduce today would be the most efficient one, its time complexity is $O(n)$, and space complexity is $O(1)$. It’s called the Boyer-Moore Majority Voting Algorithm. The code of the algorithm is pretty easy, although it’s not that easy to prove its correctness. Unlike before, I’ll show the code first, then walk through the process and prove its correctness later. I think you will better understand the algorithm this way.\nAs promised, this is the code, written in Java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int majorityElement(int[] nums) { int count = 0; int element = -1; for (int num : nums) { if (count == 0) { element = num; count = 1; } else if (element == num) { count++; } else { count--; } } return element; } } First, we create two variables count and element. The initial value of count is 0, and the initial value of element could be any, we choose -1 here. Then we iterate through the nums array. In each iteration, we decide our operation based on the current conditions, we have three choices:\nIf count is 0, then we assign num to element and reset count to 1. If element is equal to num, then we increase count by one. Otherwise we decrease count by one. At the end of the method, we return element. That’s all.\nTo see how the algorithm works, let’s suppose the nums array is [1, 3, 3, 2, 3] and go through the process step by step.\nAt first, count is 0, so we set element to 1 and count to 1. In the second iteration, the current number is 3, which is different from element 1, so decrease count to 0 In the third iteration, count is 0, so we set element to 3 and count to 1. In the fourth iteration, the current number 2 is different from element 3, so we decrease count to 0. In the last iteration, count is 0, so we set element to the current number 3 and set count to 1. In the end, we return element 3, which is the correct majority number.\nIntuition The intuition behind the algorithm is that count can be taken as a vote for element. When we encounter a different value from element, we decrease the vote, when we encounter the same value as element, we increase the vote, so in the end, the majority number will have the most votes and therefore win the contest.\nProof The above intuition is just helping you understand the problem, to prove its correctness, you need mathematical induction.\nFirst, we prove that the algorithm works when nums length is 1, which is obvious. Second, we assume that the algorithm works when nums length is less than n, we are going to prove its correctness when nums length is n. To prove the second statement, we need to discuss two conditions:\nThe first number is the majority The first number is not the majority. When the first number is the majority In the first iteration, element is the majority number, and count is 1. There are also two possibilities for the count value afterwards:\nIt never drops to 0. it drops to 0 in some iteration. For the former case, element will always be the majority number, and the return value is also the majority, so the algorithm works in this case. We will discuss the latter case in more detail. Before doing that, let’s first define some variables to help illustrate the point:\n$k$: count drops to 0 at the end of the $k$-th iteration. $n$: The length of nums. $m$: The majority number in nums. $c$: The number of $m$ in nums. For example, when nums = [2, 2, 3, 3, 5, 2, 2], the values of those variables are:\n$k = 4$ $n = 7$ $m = 2$ $c = 4$ We need to prove that in this case $m$ is also the majority number in the remaining $n - k$ numbers. To see the necessity of the proof you need to remember that we have an assumption that the algorithm works when nums length is less than $n$. So if $m$ is the majority number in the remaining $n - k$ numbers, the algorithm will correctly output the majority number $m$ after the remaining $n - k$ iterations, which means the algorithm will output $m$ after the whole $n$ iterations, which means the algorithm works in this case.\nBut how to prove that? We can use the following logic: Since count drops to 0 in the $k$-th iteration and the first number is $m$, we know that the number of $m$ in the first $k$ numbers is exactly $\\frac{k}{2}$. To prove $m$ is also the majority in the remaining $n - k$ numbers, we need to prove\n$$(c - \\frac{k}{2}) \\cdot 2 \u003e n - k \\label{1} \\tag{1}$$\nWhich is equivalent to\n$$2c - k \u003e n - k$$\nWhich is equivalent to\n$$2c \u003e n$$\nThat is true by the definition of $m$. So we know that the equation $\\eqref{1}$ holds, which means $m$ is the majority number in the remaining $n - k$ numbers. Following the previous logic said above, we know that the algorithm works when the first number is the majority.\nWhen the first number is not the majority Suppose the first number is $j$. Since $j$ is not the majority number, there has to be an iteration where count for $j$ becomes 0 for the first time, let’s say it happens at the end of the $k$-th iteration. As before, We define the following variables:\n$n$: The length of nums. $m$: The majority number in nums. $c$: The number of $m$ in nums. $a$: The number of $m$ in the first $k$ numbers. As before, we need to prove that $m$ is also the majority number in the remaining $n - k$ numbers, if we can do that, we will know that algorithm works when the first number is not the majority. Proving it is equal to proving the following equation:\n$$2 \\cdot (c - a) \u003e n - k \\label{2} \\tag{2}$$\nTo prove the equation, we first need to know that $a \\le \\frac{k}{2}$, because if $a \u003e \\frac{k}{2}$, then count would be greater than 0 at the end of the $k$-th iteration. Also, notice that we have $2c \u003e n$ by the definition of $m$. Now we have two equations, let’s write them here:\n$$a \\le \\frac{k}{2}$$\n$$2c \u003e n$$\nMultiply both sides of the first equation by $-2$ we get $-2a \\ge -k$, then we add it to $2c \u003en$, after that we get\n$$2c - 2a \u003e n - k$$\nThat is equivalent to\n$$2 \\cdot (c - a) \u003e n - k$$\nYes, that’s equation $\\eqref{2}$, and we proved it. Following the previous logic, proving it means that the algorithm works when the first number is not the majority.\nPut everything together In conclusion, we know that the algorithm works when nums length is $n$. From the mathematical induction given before, we know that the algorithm works for any nums that have a majority. Q.E.D.\n","description":"","tags":null,"title":"Find the Majority Element Using the Boyer-Moore Majority Voting Algorithm","uri":"/posts/find-the-majority-element-using-the-boyer-moore-majority-voting-algorithm/"}]
