<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title type="text">Sand</title>
    <subtitle type="html">MemE is a powerful and highly customizable GoHugo theme for personal blogs.</subtitle>
    <updated>2023-07-29T20:10:27&#43;08:00</updated>
    <id>https://sand256.xyz/</id>
    <link rel="alternate" type="text/html" href="https://sand256.xyz/" />
    <link rel="self" type="application/atom&#43;xml" href="https://sand256.xyz/atom.xml" />
    <author>
            <name>Joey</name>
            <uri>https://sand256.xyz</uri>
            
                <email>mycityofsky@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights>
    <generator uri="https://gohugo.io/" version="0.115.3">Hugo</generator>
        <entry>
            <title type="text">Take Notes for Your Todo Tasks</title>
            <link rel="alternate" type="text/html" href="https://sand256.xyz/posts/take-notes-for-your-todo-tasks/" />
            <id>https://sand256.xyz/posts/take-notes-for-your-todo-tasks/</id>
            <updated>2023-07-29T20:07:23&#43;08:00</updated>
            <published>2023-07-25T08:38:58&#43;08:00</published>
            <author>
                    <name>Joey</name>
                    <uri>https://sand256.xyz/</uri>
                    <email>mycityofsky@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Nowadays TODO management apps are everywhere. From giant tech companies to emerging individual developers, everyone is creating TODO apps. Even some programming tutorials are about how to create a TODO app. The reason behind its popularity is obvious: almost everyone needs a TODO app.</summary>
            
                <content type="html">&lt;p&gt;Nowadays TODO management apps are everywhere. From giant tech companies to emerging individual developers, everyone is creating TODO apps. Even some programming tutorials are about how to create a TODO app. The reason behind its popularity is obvious: almost everyone needs a TODO app. But unfortunately, only a small number of people know how to manage TODO tasks most efficiently.&lt;/p&gt;
&lt;p&gt;Do you know how to use a TODO app? Yes, of course you do. Just open a TODO app and add some TODO tasks to it. When one of them is finished, simply mark them as finished by clicking on the little square before each TODO item, it&amp;rsquo;s that simple, right? Yes, it could be that simple, you can manage your TODO tasks successfully in this way. But in my view, you missed an important part: you didn&amp;rsquo;t leave any notes for your TODO tasks.&lt;/p&gt;
&lt;p&gt;You may have indulged deeply in your usual task-management process, to the extent that you may not even realize the note-taking part is important. So let me give you some examples. Suppose you created the following TODO task that you needed to finish today:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After several hours of debugging and coding, you finally found the reason and fixed the problem. With fulfillment, you opened your TODO app again and marked it as finished. &amp;ldquo;Good job!&amp;rdquo; You said to yourself: &amp;ldquo;Nothing is wrong here&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;But really? In my view, you missed an important part: taking notes for the TODO tasks. You should write down how you find the reason for slowness, how you fixed it, and how to avoid similar problems in the future. What&amp;rsquo;s more, the notes are not taken after you solved the problem, they are taken &lt;strong&gt;along&lt;/strong&gt; the process of solving it. Only in that way can you benefit from the notes most.&lt;/p&gt;
&lt;h1 id=&#34;advantages-of-taking-notes-for-todo-tasks&#34;&gt;Advantages of Taking Notes for TODO Tasks&lt;/h1&gt;
&lt;p&gt;Why should I take notes for my TODO tasks? Isn&amp;rsquo;t it enough to just finish the task in any way I want? After all, the most important thing is that I&amp;rsquo;ve completed the task, right? Well, maybe, but if you don&amp;rsquo;t take notes for those tasks, you may miss something. There are some clear benefits to taking notes for TODO tasks, to name a few:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;You may encounter similar problems in the future. When that happens, you can refer to the current notes as a problem-solving template.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You may find some of those notes useful in the future, even if you won&amp;rsquo;t encounter similar problems again. For example, when solving the problem, you may learn some knowledge about CPU. You can just note them down. When you want to look up something you&amp;rsquo;ve learned about CPU several months later, you can search for &amp;ldquo;CPU&amp;rdquo; in the notes, and voila! That knowledge, along with the context - the slowness bug - pops up in front of you. Context-aware resources can help you learn more quickly and deeply.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The notes can guide you through solving the problem. This is the &lt;strong&gt;MOST IMPORTANT&lt;/strong&gt; reason why you should take notes for your TODO task. As an old saying goes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Writing is not the artifact of thinking, it&amp;rsquo;s the actual thinking process.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I believe you won&amp;rsquo;t solve the slowness problem immediately, at least not every time. You have to first reproduce the problem, then monitor all the relevant indicators to see if anything is abnormal. You may also need to adjust some parameters to see what happens. You can write all of them in the notes, and let the notes guide you through solving the problem. It&amp;rsquo;s just like solving a mathematical problem. Some problems are hard to solve. Whenever an idea comes to your mind, you need to write them down in a notebook, fiddle around with them for a while, and maybe after writing enough information can you find the right way to solve it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That being said, do notice that some TODO tasks are not suitable for taking notes. Like &amp;ldquo;Remember to take out the garbage first thing in the morning&amp;rdquo; or &amp;ldquo;Finish the code for the sharing functionality of my app&amp;rdquo;. The former is too simple to note anything down, the latter is more about coding, which is usually done in an IDE, not much to be written down in the notes.&lt;/p&gt;
&lt;h1 id=&#34;lets-take-an-example&#34;&gt;Let&amp;rsquo;s take an example&lt;/h1&gt;
&lt;p&gt;Now suppose you want to fix the problem mentioned above:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To do that, you first created a TODO task:&lt;/p&gt;
&lt;div class=&#34;callout&#34;&gt;
    &lt;h6&gt;TODO&lt;/h6&gt;
    &lt;p&gt;&lt;b&gt;Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;After creating the task, we are ready to get down to it. As everyone knows, the first thing we need to do when solving a problem would be to try reproducing it. So let&amp;rsquo;s add the following notes under the TODO task &lt;strong&gt;before&lt;/strong&gt; doing anything.&lt;/p&gt;
&lt;div class=&#34;callout&#34;&gt;
    &lt;h6&gt;TODO&lt;/h6&gt;
    &lt;p&gt;Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.&lt;/p&gt;
    &lt;h6&gt;NOTES&lt;/h6&gt;
    &lt;p&gt;&lt;b&gt;First let&#39;s try reproducing the issue by following the user&#39;s guide:&lt;/b&gt;&lt;/p&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;b&gt;Start the app.&lt;/b&gt;&lt;/li&gt;
        &lt;li&gt;&lt;b&gt;Click on the &#34;START&#34; button to start processing.&lt;/b&gt;&lt;/li&gt;
        &lt;li&gt;&lt;b&gt;Observe the duration to be longer than expected.&lt;/b&gt;&lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;After writing those notes, you started the app, clicked on the button, and found the duration to be 30 seconds, longer than the expected 3 seconds. You also wrote that in the notes&lt;/p&gt;
&lt;div class=&#34;callout&#34;&gt;
    &lt;h6&gt;TODO&lt;/h6&gt;
    &lt;p&gt;Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.&lt;/p&gt;
    &lt;h6&gt;NOTES&lt;/h6&gt;
    &lt;p&gt;First let&#39;s try reproducing the issue by following the user&#39;s guide:&lt;/p&gt;
    &lt;ol&gt;
        &lt;li&gt;Start the app.&lt;/li&gt;
        &lt;li&gt;Click on the &#34;START&#34; button to start processing.&lt;/li&gt;
        &lt;li&gt;Observe the duration to be longer than expected.&lt;/li&gt;
    &lt;/ol&gt;
    &lt;p&gt;&lt;b&gt;I&#39;ve reproduced the issue, the duration is 30 seconds, longer than the expected 3 seconds.&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;So what&amp;rsquo;s the culprit? You remembered that the number of the app&amp;rsquo;s users has increased a lot in the past few days, but the number of backend servers for the app hasn&amp;rsquo;t changed for months. Maybe these servers cannot support that many users&amp;rsquo; requests? That&amp;rsquo;s possible. To verify the assumption, we need to check the servers&amp;rsquo; logs to see if the servers&amp;rsquo; process duration has increased. As usual, add the action and the corresponding log to the notes:&lt;/p&gt;
&lt;div class=&#34;callout&#34;&gt;
    &lt;h6&gt;TODO&lt;/h6&gt;
    &lt;p&gt;Some users report that my app sometimes runs slow, I need to pinpoint the reason and fix it.&lt;/p&gt;
    &lt;h6&gt;NOTES&lt;/h6&gt;
    &lt;p&gt;First let&#39;s try reproducing the issue by following the user&#39;s guide:&lt;/p&gt;
    &lt;ol&gt;
        &lt;li&gt;Start the app.&lt;/li&gt;
        &lt;li&gt;Click on the &#34;START&#34; button to start processing.&lt;/li&gt;
        &lt;li&gt;Observe the duration to be longer than expected.&lt;/li&gt;
    &lt;/ol&gt;
    &lt;p&gt;I&#39;ve reproduced the issue, the duration is 30 seconds, longer than the expected 3 seconds.&lt;/p&gt;
    &lt;p&gt;&lt;b&gt;Maybe it&#39;s because the backend servers are overloaded. Need to check the servers&#39; logs first.&lt;/b&gt;&lt;/p&gt;
    &lt;p&gt;&lt;b&gt;The followings logs are taken from the server with IP 192.168.10.50:&lt;/b&gt;&lt;/p&gt;
    &lt;ul&gt;
    &lt;b&gt;&lt;li&gt;[2023-07-28 12:00:56] Finished processing user Joey&#39;s request, duration: 28 seconds.&lt;/li&gt;&lt;/b&gt;
    &lt;b&gt;&lt;li&gt;[2023-07-28 12:02:39] Finished processing user Rachel&#39;s request, duration: 32 seconds.&lt;/li&gt;&lt;/b&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;So the servers&amp;rsquo; request time has indeed increased. The next step would be to check the servers&amp;rsquo; various indicators, like CPU, memory, load, etc. You should also append this information to the notes. You get the idea, I won&amp;rsquo;t go into details anymore. The writing process can guide you through fixing the issue. What&amp;rsquo;s more, you may find the notes useful someday in the future, I cannot tell you how many times I got valuable information about the past in previous TODO notes!&lt;/p&gt;
&lt;h1 id=&#34;as-for-note-taking-what-counts-as-a-good-todo-appscheme&#34;&gt;As for Note-Taking, What Counts as a Good TODO App/Scheme?&lt;/h1&gt;
&lt;p&gt;Now you know why TODO notes are important and how to take them, the next question would be which TODO app we should use. But before making a choice, we may need to consider what features we want from a TODO app in terms of note-taking. In my view, three features are the most important:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;It has to support adding notes for each TODO task.&lt;/strong&gt; Since we are talking about notes, this feature is an obvious one.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The notes should support text formatting like italics, code blocks, etc.&lt;/strong&gt; This is because our notes could be complicated sometimes. We may need to write code blocks, headers, quotes, etc in the notes to make it easy to understand. It would be hard to take long notes without the feature.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The whole TODO list should be stored in, or at least can be imported and exported to, a plain text format&lt;/strong&gt;. By plain text format, I mean Markdown, Org Mode, etc. They are powerful enough to store multiple formats in a single text file. To be honest, this is not a must-have feature, but it&amp;rsquo;s nice to have. When your TODO list is stored in a plain text format, you can search for/edit anything you want with any editor, you will not be bound to a certain vendor product.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;how-does-each-todo-app-do-in-terms-of-note-taking&#34;&gt;How Does Each TODO App Do in Terms of Note-Taking?&lt;/h1&gt;
&lt;p&gt;Now we have three requirements for TODO apps, let&amp;rsquo;s take a look at some well-known TODO apps and see how each of them does in this regard.&lt;/p&gt;
&lt;h2 id=&#34;microsoft-to-do&#34;&gt;Microsoft To Do&lt;/h2&gt;
&lt;p&gt;One of the most famous TODO apps is &lt;a href=&#34;https://todo.microsoft.com/tasks/&#34;&gt;Microsoft To Do&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sand256.xyz/images/microsoft-to-do-notes.png&#34; alt=&#34;Notes in Microsoft To Do&#34;&gt;&lt;/p&gt;
&lt;p&gt;Microsoft To Do allows you to take notes for each task at the right bottom part of the UI (Found the &amp;ldquo;Add Note&amp;rdquo; part in the image above?). That&amp;rsquo;s enough for most people, but the notes can only be plain text, it doesn&amp;rsquo;t support quotes, code blocks, etc. So it&amp;rsquo;s not the perfect solution. Maybe Microsoft doesn&amp;rsquo;t want the app to be complicated. If the user needs to take notes with formatting elements (heading, bulleted lists), he/she can do this in other apps. Besides, you can only see/edit TODO tasks inside the app, there is no way to export the TODO list to a text file. So Microsoft To Do only supports the first feature.&lt;/p&gt;
&lt;p&gt;Score: ★★★☆☆&lt;/p&gt;
&lt;h2 id=&#34;todoist&#34;&gt;Todoist&lt;/h2&gt;
&lt;p&gt;Todoist is also a famous TODO management app, it seems to have more features than Microsoft To Do. You can try creating a TODO task and adding some notes to it, then you will immediately realize that the app surely supports the first two features - It supports Markdown in its TODO description/comments and renders it perfectly:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sand256.xyz/images/todoist.png&#34; alt=&#34;Todoist&#34;&gt;&lt;/p&gt;
&lt;p&gt;It doesn&amp;rsquo;t support importing/exporting the TODO list to a text file, but it supports the first two features perfectly.&lt;/p&gt;
&lt;p&gt;Score: ★★★★☆&lt;/p&gt;
&lt;h1 id=&#34;agenda&#34;&gt;Agenda&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://agenda.com/&#34;&gt;Agenda&lt;/a&gt; is built based on the idea that notes and dates should be combined together, which is closely aligned with ours. Strictly speaking, it&amp;rsquo;s not a TODO app, at least not a traditional one, the official website describes the app as &lt;em&gt;Notes meets Calendar&lt;/em&gt;. But since it can set a date for a block of notes, you can use it as a TODO app with notes emphasized.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sand256.xyz/images/agenda.png&#34; alt=&#34;Agenda&#34;&gt;&lt;/p&gt;
&lt;p&gt;Agenda has a premium feature that supports exporting the notes into markdown files. I haven&amp;rsquo;t bought Agenda so I don&amp;rsquo;t know how it does. But I guess it should work. So in summary, Agenda supports all the three features we mentioned above, which seems to be a great app worth trying.&lt;/p&gt;
&lt;p&gt;Score: ★★★★☆&lt;/p&gt;
&lt;h2 id=&#34;emacs-with-org-mode&#34;&gt;Emacs With Org Mode&lt;/h2&gt;
&lt;p&gt;This is my favorite one. But a lot of people don&amp;rsquo;t know Emacs or Org Mode at all, maybe because it&amp;rsquo;s a niche product mainly used by programmers.&lt;/p&gt;
&lt;p&gt;First of all, Emacs and Org Mode are two separate things. Emacs is a highly-customizable text editor, just like Vim, while Org Mode is a markup language, just like Markdown. It&amp;rsquo;s not as popular as Markdown so a lot of people don&amp;rsquo;t know it. Theoretically, you can edit Org Mode documents with any editor, but most people choose Emacs because it has excellent support for Org Mode.&lt;/p&gt;
&lt;p&gt;Org Mode has many attractive features that are not available in Markdown. Since we are talking about notes and TODO tasks, I&amp;rsquo;ll only highlight relevant features in Org Mode. In Markdown, we add a header with &lt;code&gt;#&lt;/code&gt;. That&amp;rsquo;s similar in Org Mode, only that we use &lt;code&gt;*&lt;/code&gt; instead of &lt;code&gt;#&lt;/code&gt;. Moreover, You can add the &lt;code&gt;TODO&lt;/code&gt; keyword after &lt;code&gt;*&lt;/code&gt; in Org Mode to make it a TODO header, here is an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-org&#34; data-lang=&#34;org&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;err&#34;&gt; TODO&lt;/span&gt;&lt;span class=&#34;gs&#34;&gt; Install Emacs in macOS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gu&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;sr&#34;&gt; DONE&lt;/span&gt; Install vanilla Emacs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;We can use &lt;span class=&#34;nc&#34;&gt;~brew~&lt;/span&gt; to install vanilla Emacs, the command is as follows&lt;span class=&#34;bp&#34;&gt;[fn:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;]&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;#+begin_src &lt;/span&gt;&lt;span class=&#34;cs&#34;&gt;sh&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;brew update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;brew install emacs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;#+end_src&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gu&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;err&#34;&gt; TODO&lt;/span&gt; Install Doom Emacs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Run the following command to install Doom Emacs&lt;span class=&#34;bp&#34;&gt;[fn:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;]&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;#+begin_src &lt;/span&gt;&lt;span class=&#34;cs&#34;&gt;sh&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;git clone --depth &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; https://github.com/doomemacs/doomemacs ~/.config/emacs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~/.config/emacs/bin/doom install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;#+end_src&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gh&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;gs&#34;&gt; Footnotes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;bp&#34;&gt;[fn:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;]&lt;/span&gt; [[&lt;span class=&#34;na&#34;&gt;https://orgmode.org/org.html#Installation&lt;/span&gt;][&lt;span class=&#34;nt&#34;&gt;The official Org Mode website&lt;/span&gt;]]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;bp&#34;&gt;[fn:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;]&lt;/span&gt; [[&lt;span class=&#34;na&#34;&gt;https://github.com/doomemacs/doomemacs&lt;/span&gt;][&lt;span class=&#34;nt&#34;&gt;The Doom Emacs git repository&lt;/span&gt;]]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Here is how it looks like in Emacs (You may get a different rendering effect depending on your Emacs configurations):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sand256.xyz/images/org-mode-rendering.png&#34; alt=&#34;Org Mode rendering&#34;&gt;&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s just like Markdown, only using a different set of symbols. I won&amp;rsquo;t try to tell you all the meanings of those symbols, but you can guess. Here we created a top TODO task, which is to &lt;em&gt;install Emacs on macOS&lt;/em&gt;. When we add this TODO task, we may know nothing about how to do that. After some investigations, we may find that we need to install two parts, the first is vanilla Emacs, and the second is Doom Emacs. Again, you don&amp;rsquo;t need to know what they are, the point is that we figured out we need to install two parts, so we need to create two sub-tasks under the main task. Then we list all the commands we need to run to install them. We can also attach the result to the notes (By the way, Emacs can run those commands directly in the notes!) so that whenever any error occurs, the result can be taken as a good reference for pinpointing the reason.&lt;/p&gt;
&lt;p&gt;In the end, when we finished the first sub-task, we change the &lt;code&gt;TODO&lt;/code&gt; keyword to &lt;code&gt;DONE&lt;/code&gt;, just like we change &lt;code&gt;- [ ]&lt;/code&gt; to &lt;code&gt;- [X]&lt;/code&gt; in Markdown. It not only removes the TODO task from the TODO list but also gives us &amp;ldquo;a dose of dopamine&amp;rdquo; for finishing the task.&lt;/p&gt;
&lt;p&gt;Although Org Mode is great in many ways, few apps support Org Mode, and Emacs is almost the only app that supports all the features of Org Mode. Yes, you can edit Org Mode files in any editor you want. But if you want to do something with TODO tasks in Org Mode files, like checking TODO tasks scheduled at a certain date, or checking all the TODO tasks with the highest priority, Emacs might be your only option. And here comes its biggest problem: Emacs is not that easy to learn, even for professional programmers. That is a huge obstacle for ordinary people.&lt;/p&gt;
&lt;p&gt;Emacs with Org Mode supports all the three features mentioned above, but it&amp;rsquo;s hard to learn, which is a deal killer for most people, so I&amp;rsquo;ll only give it three stars, although it&amp;rsquo;s my favorite.&lt;/p&gt;
&lt;p&gt;Score: ★★★☆☆&lt;/p&gt;
&lt;h1 id=&#34;now-what-should-i-choose&#34;&gt;Now What Should I Choose?&lt;/h1&gt;
&lt;p&gt;There are many TODO apps nowadays, and most of them support adding notes, only the degree of support varies. You may ask which one to choose, and my answer to that question would be: just pick one, don&amp;rsquo;t hesitate. In my view, the biggest problem is not that most TODO apps don&amp;rsquo;t have great support for notes. The biggest problem is that most people don&amp;rsquo;t know they should take notes for their TODO tasks. So just pick one TODO app, and start taking your TODO notes from today!&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Find the Majority Element Using the Boyer-Moore Majority Voting Algorithm</title>
            <link rel="alternate" type="text/html" href="https://sand256.xyz/posts/find-the-majority-element-using-the-boyer-moore-majority-voting-algorithm/" />
            <id>https://sand256.xyz/posts/find-the-majority-element-using-the-boyer-moore-majority-voting-algorithm/</id>
            <updated>2023-07-22T06:59:13&#43;08:00</updated>
            <published>2023-07-18T07:03:22&#43;08:00</published>
            <author>
                    <name>Joey</name>
                    <uri>https://sand256.xyz/</uri>
                    <email>mycityofsky@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Introduction Recently I encountered a leetcode problem called Majority Element, there are multiple ways to solve it, the most efficient of them all is called the Boyer-Moore Majority Voting Algorithm, whose time complexity is $O(n)$ and space complexity is $O(1)$. There are many posts online talking about the algorithm, but most of them don&amp;rsquo;t give a concrete mathematical proof of it.</summary>
            
                <content type="html">&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Recently I encountered a leetcode problem called &lt;a href=&#34;https://leetcode.com/problems/majority-element/description/&#34;&gt;Majority Element&lt;/a&gt;, there are multiple ways to solve it, the most efficient of them all is called &lt;strong&gt;the Boyer-Moore Majority Voting Algorithm&lt;/strong&gt;, whose time complexity is $O(n)$ and space complexity is $O(1)$. There are many posts online talking about the algorithm, but most of them don&amp;rsquo;t give a concrete mathematical proof of it. So in this post, I try to explain the algorithm thoroughly, including not only its mechanism and intuition but also a mathematical proof.&lt;/p&gt;
&lt;h1 id=&#34;problem&#34;&gt;Problem&lt;/h1&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of size $n$, return the majority element.&lt;/p&gt;
&lt;p&gt;The majority element is the element that appears more than &lt;code&gt;⌊n / 2⌋&lt;/code&gt; times. You may assume that the majority element always exists in the array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Input: nums = [3,2,3]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Output: 3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Input: nums = [2,2,1,1,1,2,2]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Output: 2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;the-boyer-moore-majority-voting-algorithm&#34;&gt;The Boyer-Moore Majority Voting Algorithm&lt;/h1&gt;
&lt;p&gt;There are a lot of ways to solve the problem, but the method I’ll introduce today would be the most efficient one, its time complexity is $O(n)$, and space complexity is $O(1)$. It’s called &lt;strong&gt;the Boyer-Moore Majority Voting Algorithm&lt;/strong&gt;. The code of the algorithm is pretty easy, although it’s not that easy to prove its correctness. Unlike before, I’ll show the code first, then walk through the process and prove its correctness later. I think you will better understand the algorithm this way.&lt;/p&gt;
&lt;p&gt;As promised, this is the code, written in Java&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;majorityElement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;First, we create two variables &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;element&lt;/code&gt;. The initial value of &lt;code&gt;count&lt;/code&gt; is 0, and the initial value of &lt;code&gt;element&lt;/code&gt; could be any, we choose -1 here. Then we iterate through the &lt;code&gt;nums&lt;/code&gt; array. In each iteration, we decide our operation based on the current conditions, we have three choices:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;count&lt;/code&gt; is 0, then we assign &lt;code&gt;num&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt; and reset &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;element&lt;/code&gt; is equal to &lt;code&gt;num&lt;/code&gt;, then we increase &lt;code&gt;count&lt;/code&gt; by one.&lt;/li&gt;
&lt;li&gt;Otherwise we decrease &lt;code&gt;count&lt;/code&gt; by one.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;At the end of the method, we return &lt;code&gt;element&lt;/code&gt;. That’s all.&lt;/p&gt;
&lt;p&gt;To see how the algorithm works, let’s suppose the &lt;code&gt;nums&lt;/code&gt; array is &lt;code&gt;[1, 3, 3, 2, 3]&lt;/code&gt; and go through the process step by step.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;At first, &lt;code&gt;count&lt;/code&gt; is 0, so we set &lt;code&gt;element&lt;/code&gt; to 1 and &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;li&gt;In the second iteration, the current number is 3, which is different from &lt;code&gt;element&lt;/code&gt; 1, so decrease &lt;code&gt;count&lt;/code&gt; to 0&lt;/li&gt;
&lt;li&gt;In the third iteration, &lt;code&gt;count&lt;/code&gt; is 0, so we set &lt;code&gt;element&lt;/code&gt; to 3 and &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;li&gt;In the fourth iteration, the current number 2 is different from &lt;code&gt;element&lt;/code&gt; 3, so we decrease &lt;code&gt;count&lt;/code&gt; to 0.&lt;/li&gt;
&lt;li&gt;In the last iteration, &lt;code&gt;count&lt;/code&gt; is 0, so we set &lt;code&gt;element&lt;/code&gt; to the current number 3 and set &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the end, we return &lt;code&gt;element&lt;/code&gt; 3, which is the correct majority number.&lt;/p&gt;
&lt;h1 id=&#34;intuition&#34;&gt;Intuition&lt;/h1&gt;
&lt;p&gt;The intuition behind the algorithm is that &lt;code&gt;count&lt;/code&gt; can be taken as a vote for &lt;code&gt;element&lt;/code&gt;. When we encounter a different value from &lt;code&gt;element&lt;/code&gt;, we decrease the vote, when we encounter the same value as &lt;code&gt;element&lt;/code&gt;, we increase the vote, so in the end, the majority number will have the most votes and therefore win the contest.&lt;/p&gt;
&lt;h1 id=&#34;proof&#34;&gt;Proof&lt;/h1&gt;
&lt;p&gt;The above intuition is just helping you understand the problem, to prove its correctness, you need mathematical induction.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;First, we prove that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is 1, which is obvious.&lt;/li&gt;
&lt;li&gt;Second, we assume that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is less than &lt;code&gt;n&lt;/code&gt;, we are going to prove its correctness when &lt;code&gt;nums&lt;/code&gt; length is &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To prove the second statement, we need to discuss two conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first number is the majority&lt;/li&gt;
&lt;li&gt;The first number is not the majority.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;when-the-first-number-is-the-majority&#34;&gt;When the first number is the majority&lt;/h2&gt;
&lt;p&gt;In the first iteration, &lt;code&gt;element&lt;/code&gt; is the majority number, and &lt;code&gt;count&lt;/code&gt; is 1. There are also two possibilities for the &lt;code&gt;count&lt;/code&gt; value afterwards:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It never drops to 0.&lt;/li&gt;
&lt;li&gt;it drops to 0 in some iteration.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the former case, &lt;code&gt;element&lt;/code&gt; will always be the majority number, and the return value is also the majority, so the algorithm works in this case. We will discuss the latter case in more detail. Before doing that, let&amp;rsquo;s first define some variables to help illustrate the point:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$k$: &lt;code&gt;count&lt;/code&gt; drops to 0 at the end of the $k$-th iteration.&lt;/li&gt;
&lt;li&gt;$n$: The length of &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$m$: The majority number in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$c$: The number of $m$ in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, when &lt;code&gt;nums = [2, 2, 3, 3, 5, 2, 2]&lt;/code&gt;, the values of those variables are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$k = 4$&lt;/li&gt;
&lt;li&gt;$n = 7$&lt;/li&gt;
&lt;li&gt;$m = 2$&lt;/li&gt;
&lt;li&gt;$c = 4$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We need to prove that in this case $m$ is also the majority number in the remaining $n - k$ numbers. To see the necessity of the proof you need to remember that we have an assumption that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is less than $n$. So if $m$ is the majority number in the remaining $n - k$ numbers, the algorithm will correctly output the majority number $m$ after the remaining $n - k$ iterations, which means the algorithm will output $m$ after the whole $n$ iterations, which means the algorithm works in this case.&lt;/p&gt;
&lt;p&gt;But how to prove that? We can use the following logic: Since &lt;code&gt;count&lt;/code&gt; drops to 0 in the $k$-th iteration and the first number is $m$, we know that the number of $m$ in the first $k$ numbers is exactly $\frac{k}{2}$. To prove $m$ is also the majority in the remaining $n - k$ numbers, we need to prove&lt;/p&gt;
&lt;p&gt;$$(c - \frac{k}{2}) \cdot 2 &amp;gt; n - k \label{1} \tag{1}$$&lt;/p&gt;
&lt;p&gt;Which is equivalent to&lt;/p&gt;
&lt;p&gt;$$2c - k &amp;gt; n - k$$&lt;/p&gt;
&lt;p&gt;Which is equivalent to&lt;/p&gt;
&lt;p&gt;$$2c &amp;gt; n$$&lt;/p&gt;
&lt;p&gt;That is true by the definition of $m$. So we know that the equation $\eqref{1}$ holds, which means $m$ is the majority number in the remaining $n - k$ numbers. Following the previous logic said above, we know that the algorithm works when the first number is the majority.&lt;/p&gt;
&lt;h2 id=&#34;when-the-first-number-is-not-the-majority&#34;&gt;When the first number is not the majority&lt;/h2&gt;
&lt;p&gt;Suppose the first number is $j$. Since $j$ is not the majority number, there has to be an iteration where &lt;code&gt;count&lt;/code&gt; for $j$ becomes 0 for the first time, let’s say it happens at the end of the $k$-th iteration. As before, We define the following variables:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$n$: The length of &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$m$: The majority number in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$c$: The number of $m$ in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$a$: The number of $m$ in the first $k$ numbers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As before, we need to prove that $m$ is also the majority number in the remaining $n - k$ numbers, if we can do that, we will know that algorithm works when the first number is not the majority. Proving it is equal to proving the following equation:&lt;/p&gt;
&lt;p&gt;$$2 \cdot (c - a) &amp;gt; n - k \label{2} \tag{2}$$&lt;/p&gt;
&lt;p&gt;To prove the equation, we first need to know that $a \le \frac{k}{2}$, because if $a &amp;gt; \frac{k}{2}$, then &lt;code&gt;count&lt;/code&gt; would be greater than 0 at the end of the $k$-th iteration. Also, notice that we have $2c &amp;gt; n$ by the definition of $m$. Now we have two equations, let&amp;rsquo;s write them here:&lt;/p&gt;
&lt;p&gt;$$a \le \frac{k}{2}$$&lt;/p&gt;
&lt;p&gt;$$2c &amp;gt; n$$&lt;/p&gt;
&lt;p&gt;Multiply both sides of the first equation by $-2$ we get $-2a \ge -k$, then we add it to $2c &amp;gt;n$, after that we get&lt;/p&gt;
&lt;p&gt;$$2c - 2a &amp;gt; n - k$$&lt;/p&gt;
&lt;p&gt;That is equivalent to&lt;/p&gt;
&lt;p&gt;$$2 \cdot (c - a) &amp;gt; n - k$$&lt;/p&gt;
&lt;p&gt;Yes, that&amp;rsquo;s equation $\eqref{2}$, and we proved it. Following the previous logic, proving it means that the algorithm works when the first number is not the majority.&lt;/p&gt;
&lt;h2 id=&#34;put-everything-together&#34;&gt;Put everything together&lt;/h2&gt;
&lt;p&gt;In conclusion, we know that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is $n$. From the mathematical induction given before, we know that the algorithm works for any &lt;code&gt;nums&lt;/code&gt; that have a majority. Q.E.D.&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
</feed>
