<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title type="text">Sand</title>
    <subtitle type="html">MemE is a powerful and highly customizable GoHugo theme for personal blogs.</subtitle>
    <updated>2023-07-22T09:50:32&#43;08:00</updated>
    <id>https://sand256.xyz/</id>
    <link rel="alternate" type="text/html" href="https://sand256.xyz/" />
    <link rel="self" type="application/atom&#43;xml" href="https://sand256.xyz/atom.xml" />
    <author>
            <name>Joey</name>
            <uri>https://sand256.xyz</uri>
            
                <email>mycityofsky@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights>
    <generator uri="https://gohugo.io/" version="0.115.3">Hugo</generator>
        <entry>
            <title type="text">Find the Majority Element Using the Boyer-Moore Majority Voting Algorithm</title>
            <link rel="alternate" type="text/html" href="https://sand256.xyz/posts/find-the-majority-element-using-the-boyer-moore-majority-voting-algorithm/" />
            <id>https://sand256.xyz/posts/find-the-majority-element-using-the-boyer-moore-majority-voting-algorithm/</id>
            <updated>2023-07-22T06:59:13&#43;08:00</updated>
            <published>2023-07-18T07:03:22&#43;08:00</published>
            <author>
                    <name>Joey</name>
                    <uri>https://sand256.xyz/</uri>
                    <email>mycityofsky@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</rights><summary type="html">Introduction Recently I encountered a leetcode problem called Majority Element, there are multiple ways to solve it, the most efficient of them all is called the Boyer-Moore Majority Voting Algorithm, whose time complexity is $O(n)$ and space complexity is $O(1)$. There are many posts online talking about the algorithm, but most of them don&amp;rsquo;t give a concrete mathematical proof of it.</summary>
            
                <content type="html">&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Recently I encountered a leetcode problem called &lt;a href=&#34;https://leetcode.com/problems/majority-element/description/&#34;&gt;Majority Element&lt;/a&gt;, there are multiple ways to solve it, the most efficient of them all is called &lt;strong&gt;the Boyer-Moore Majority Voting Algorithm&lt;/strong&gt;, whose time complexity is $O(n)$ and space complexity is $O(1)$. There are many posts online talking about the algorithm, but most of them don&amp;rsquo;t give a concrete mathematical proof of it. So in this post, I try to explain the algorithm thoroughly, including not only its mechanism and intuition but also a mathematical proof.&lt;/p&gt;
&lt;h1 id=&#34;problem&#34;&gt;Problem&lt;/h1&gt;
&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of size $n$, return the majority element.&lt;/p&gt;
&lt;p&gt;The majority element is the element that appears more than &lt;code&gt;⌊n / 2⌋&lt;/code&gt; times. You may assume that the majority element always exists in the array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Input: nums = [3,2,3]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Output: 3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Input: nums = [2,2,1,1,1,2,2]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Output: 2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;the-boyer-moore-majority-voting-algorithm&#34;&gt;The Boyer-Moore Majority Voting Algorithm&lt;/h1&gt;
&lt;p&gt;There are a lot of ways to solve the problem, but the method I’ll introduce today would be the most efficient one, its time complexity is $O(n)$, and space complexity is $O(1)$. It’s called &lt;strong&gt;the Boyer-Moore Majority Voting Algorithm&lt;/strong&gt;. The code of the algorithm is pretty easy, although it’s not that easy to prove its correctness. Unlike before, I’ll show the code first, then walk through the process and prove its correctness later. I think you will better understand the algorithm this way.&lt;/p&gt;
&lt;p&gt;As promised, this is the code, written in Java&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;majorityElement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;element&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;First, we create two variables &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;element&lt;/code&gt;. The initial value of &lt;code&gt;count&lt;/code&gt; is 0, and the initial value of &lt;code&gt;element&lt;/code&gt; could be any, we choose -1 here. Then we iterate through the &lt;code&gt;nums&lt;/code&gt; array. In each iteration, we decide our operation based on the current conditions, we have three choices:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;count&lt;/code&gt; is 0, then we assign &lt;code&gt;num&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt; and reset &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;element&lt;/code&gt; is equal to &lt;code&gt;num&lt;/code&gt;, then we increase &lt;code&gt;count&lt;/code&gt; by one.&lt;/li&gt;
&lt;li&gt;Otherwise we decrease &lt;code&gt;count&lt;/code&gt; by one.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;At the end of the method, we return &lt;code&gt;element&lt;/code&gt;. That’s all.&lt;/p&gt;
&lt;p&gt;To see how the algorithm works, let’s suppose the &lt;code&gt;nums&lt;/code&gt; array is &lt;code&gt;[1, 3, 3, 2, 3]&lt;/code&gt; and go through the process step by step.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;At first, &lt;code&gt;count&lt;/code&gt; is 0, so we set &lt;code&gt;element&lt;/code&gt; to 1 and &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;li&gt;In the second iteration, the current number is 3, which is different from &lt;code&gt;element&lt;/code&gt; 1, so decrease &lt;code&gt;count&lt;/code&gt; to 0&lt;/li&gt;
&lt;li&gt;In the third iteration, &lt;code&gt;count&lt;/code&gt; is 0, so we set &lt;code&gt;element&lt;/code&gt; to 3 and &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;li&gt;In the fourth iteration, the current number 2 is different from &lt;code&gt;element&lt;/code&gt; 3, so we decrease &lt;code&gt;count&lt;/code&gt; to 0.&lt;/li&gt;
&lt;li&gt;In the last iteration, &lt;code&gt;count&lt;/code&gt; is 0, so we set &lt;code&gt;element&lt;/code&gt; to the current number 3 and set &lt;code&gt;count&lt;/code&gt; to 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the end, we return &lt;code&gt;element&lt;/code&gt; 3, which is the correct majority number.&lt;/p&gt;
&lt;h1 id=&#34;intuition&#34;&gt;Intuition&lt;/h1&gt;
&lt;p&gt;The intuition behind the algorithm is that &lt;code&gt;count&lt;/code&gt; can be taken as a vote for &lt;code&gt;element&lt;/code&gt;. When we encounter a different value from &lt;code&gt;element&lt;/code&gt;, we decrease the vote, when we encounter the same value as &lt;code&gt;element&lt;/code&gt;, we increase the vote, so in the end, the majority number will have the most votes and therefore win the contest.&lt;/p&gt;
&lt;h1 id=&#34;proof&#34;&gt;Proof&lt;/h1&gt;
&lt;p&gt;The above intuition is just helping you understand the problem, to prove its correctness, you need mathematical induction.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;First, we prove that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is 1, which is obvious.&lt;/li&gt;
&lt;li&gt;Second, we assume that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is less than &lt;code&gt;n&lt;/code&gt;, we are going to prove its correctness when &lt;code&gt;nums&lt;/code&gt; length is &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To prove the second statement, we need to discuss two conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first number is the majority&lt;/li&gt;
&lt;li&gt;The first number is not the majority.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;when-the-first-number-is-the-majority&#34;&gt;When the first number is the majority&lt;/h2&gt;
&lt;p&gt;In the first iteration, &lt;code&gt;element&lt;/code&gt; is the majority number, and &lt;code&gt;count&lt;/code&gt; is 1. There are also two possibilities for the &lt;code&gt;count&lt;/code&gt; value afterwards:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It never drops to 0.&lt;/li&gt;
&lt;li&gt;it drops to 0 in some iteration.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the former case, &lt;code&gt;element&lt;/code&gt; will always be the majority number, and the return value is also the majority, so the algorithm works in this case. We will discuss the latter case in more detail. Before doing that, let&amp;rsquo;s first define some variables to help illustrate the point:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$k$: &lt;code&gt;count&lt;/code&gt; drops to 0 at the end of the $k$-th iteration.&lt;/li&gt;
&lt;li&gt;$n$: The length of &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$m$: The majority number in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$c$: The number of $m$ in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, when &lt;code&gt;nums = [2, 2, 3, 3, 5, 2, 2]&lt;/code&gt;, the values of those variables are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$k = 4$&lt;/li&gt;
&lt;li&gt;$n = 7$&lt;/li&gt;
&lt;li&gt;$m = 2$&lt;/li&gt;
&lt;li&gt;$c = 4$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We need to prove that in this case $m$ is also the majority number in the remaining $n - k$ numbers. To see the necessity of the proof you need to remember that we have an assumption that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is less than $n$. So if $m$ is the majority number in the remaining $n - k$ numbers, the algorithm will correctly output the majority number $m$ after the remaining $n - k$ iterations, which means the algorithm will output $m$ after the whole $n$ iterations, which means the algorithm works in this case.&lt;/p&gt;
&lt;p&gt;But how to prove that? We can use the following logic: Since &lt;code&gt;count&lt;/code&gt; drops to 0 in the $k$-th iteration and the first number is $m$, we know that the number of $m$ in the first $k$ numbers is exactly $\frac{k}{2}$. To prove $m$ is also the majority in the remaining $n - k$ numbers, we need to prove&lt;/p&gt;
&lt;p&gt;$$(c - \frac{k}{2}) \cdot 2 &amp;gt; n - k \label{1} \tag{1}$$&lt;/p&gt;
&lt;p&gt;Which is equivalent to&lt;/p&gt;
&lt;p&gt;$$2c - k &amp;gt; n - k$$&lt;/p&gt;
&lt;p&gt;Which is equivalent to&lt;/p&gt;
&lt;p&gt;$$2c &amp;gt; n$$&lt;/p&gt;
&lt;p&gt;That is true by the definition of $m$. So we know that the equation $\eqref{1}$ holds, which means $m$ is the majority number in the remaining $n - k$ numbers. Following the previous logic said above, we know that the algorithm works when the first number is the majority.&lt;/p&gt;
&lt;h2 id=&#34;when-the-first-number-is-not-the-majority&#34;&gt;When the first number is not the majority&lt;/h2&gt;
&lt;p&gt;Suppose the first number is $j$. Since $j$ is not the majority number, there has to be an iteration where &lt;code&gt;count&lt;/code&gt; for $j$ becomes 0 for the first time, let’s say it happens at the end of the $k$-th iteration. As before, We define the following variables:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$n$: The length of &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$m$: The majority number in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$c$: The number of $m$ in &lt;code&gt;nums&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;$a$: The number of $m$ in the first $k$ numbers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As before, we need to prove that $m$ is also the majority number in the remaining $n - k$ numbers, if we can do that, we will know that algorithm works when the first number is not the majority. Proving it is equal to proving the following equation:&lt;/p&gt;
&lt;p&gt;$$2 \cdot (c - a) &amp;gt; n - k \label{2} \tag{2}$$&lt;/p&gt;
&lt;p&gt;To prove the equation, we first need to know that $a \le \frac{k}{2}$, because if $a &amp;gt; \frac{k}{2}$, then &lt;code&gt;count&lt;/code&gt; would be greater than 0 at the end of the $k$-th iteration. Also, notice that we have $2c &amp;gt; n$ by the definition of $m$. Now we have two equations, let&amp;rsquo;s write them here:&lt;/p&gt;
&lt;p&gt;$$a \le \frac{k}{2}$$&lt;/p&gt;
&lt;p&gt;$$2c &amp;gt; n$$&lt;/p&gt;
&lt;p&gt;Multiply both sides of the first equation by $-2$ we get $-2a \ge -k$, then we add it to $2c &amp;gt;n$, after that we get&lt;/p&gt;
&lt;p&gt;$$2c - 2a &amp;gt; n - k$$&lt;/p&gt;
&lt;p&gt;That is equivalent to&lt;/p&gt;
&lt;p&gt;$$2 \cdot (c - a) &amp;gt; n - k$$&lt;/p&gt;
&lt;p&gt;Yes, that&amp;rsquo;s equation $\eqref{2}$, and we proved it. Following the previous logic, proving it means that the algorithm works when the first number is not the majority.&lt;/p&gt;
&lt;h2 id=&#34;put-everything-together&#34;&gt;Put everything together&lt;/h2&gt;
&lt;p&gt;In conclusion, we know that the algorithm works when &lt;code&gt;nums&lt;/code&gt; length is $n$. From the mathematical induction given before, we know that the algorithm works for any &lt;code&gt;nums&lt;/code&gt; that have a majority. Q.E.D.&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
</feed>
